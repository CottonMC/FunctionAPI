import java.util.regex.Pattern

plugins {
    id 'fabric-loom' version '0.2.4-SNAPSHOT'
    id 'maven-publish'
    id "com.jfrog.artifactory" version "4.9.0"
}

sourceCompatibility = JavaVersion.VERSION_1_8
targetCompatibility = JavaVersion.VERSION_1_8

archivesBaseName = "function-api"
version = project.mod_version
group = project.maven_group

repositories {
    mavenCentral()
    maven { url 'http://server.bbkr.space:8081/artifactory/libs-release' }
}

if (rootProject.file('private.gradle').exists()) { //Publishing details
    apply from: 'private.gradle'
}

minecraft {
}

ext.generatedResources = project.buildDir.absolutePath + "/generated/resources/"

file(ext.generatedResources).mkdirs()
sourceSets {
    main {
        resources {
            srcDir project.ext.generatedResources
        }
    }
}
dependencies {
    //to change the versions see the gradle.properties file
    minecraft "com.mojang:minecraft:${project.minecraft_version}"
    mappings "net.fabricmc:yarn:${project.yarn_mappings}"
    modCompile "net.fabricmc:fabric-loader:${project.loader_version}"
    modApi "net.fabricmc.fabric-api:fabric-api:0.3.2+build.218-1.14"

    // Fabric API. This is technically optional, but you probably want it anyway.

    modRuntime(group: 'io.github.cottonmc.cotton', name: 'cotton-datapack', version: '1.0.0-rc.1', classifier: 'dev') {
        transitive = false
    }
    modRuntime(group: 'io.github.cottonmc.cotton', name: 'cotton-logging', version: '1.0.0-rc.1', classifier: 'dev') {
        transitive = false
    }
    modRuntime(group: 'io.github.cottonmc.cotton', name: 'cotton-config', version: '1.0.0-rc.1', classifier: 'dev') {
        transitive = false
    }
    //modCompile(group: 'io.github.cottonmc', name: 'cotton-scripting', version: '1.2.0+1.14', classifier: 'dev')
    modRuntime(group: 'io.github.cottonmc', name: 'Jankson', version: '1.0.0+j1.1.2', classifier: 'dev') {
        transitive = false
    }


    modCompile(group: 'io.github.cottonmc', name: 'StaticData', version: '1.0.0', classifier: 'dev')
    include(group: 'io.github.cottonmc', name: 'StaticData', version: '1.0.0')


    // PSA: Some older mods, compiled on Loom 0.2.1, might have outdated Maven POMs.
    // You may need to force-disable transitiveness on them.
}

processResources {
    inputs.property "version", project.version

    from(sourceSets.main.resources.srcDirs) {
        include "fabric.mod.json"
        expand "version": project.version
    }

    from(sourceSets.main.resources.srcDirs) {
        exclude "fabric.mod.json"
    }
}

// ensure that the encoding is set to UTF-8, no matter what the system default is
// this fixes some edge cases with special characters not displaying correctly
// see http://yodaconditions.net/blog/fix-for-java-file-encoding-problems-with-gradle.html
tasks.withType(JavaCompile) {
    options.encoding = "UTF-8"
}

// Loom will automatically attach sourcesJar to a RemapSourcesJar task and to the "build" task
// if it is present.
// If you remove this task, sources will not be generated.
task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = "sources"
    from sourceSets.main.allSource
}

jar {
    from "LICENSE"
}

// configure the maven publication
publishing {
    publications {
        maven(MavenPublication) {
            from components.java

            artifactId = project.archives_base_name


            pom.withXml {
                def pomFile = asNode()
                def depsNode = pomFile.get("dependencies")
                pomFile.remove(depsNode)

                def newDeps = pomFile.appendNode("dependencies")
                configurations.modCompile.getResolvedConfiguration().getFirstLevelModuleDependencies().each {
                    def artifactNode = newDeps.appendNode("dependency")
                    artifactNode.appendNode('groupId', it.moduleGroup)
                    artifactNode.appendNode('artifactId', it.moduleName)
                    artifactNode.appendNode('version', it.moduleVersion)
                }
            }
            artifacts = [
                    artifact("${project.buildDir.absolutePath}/libs/${archivesBaseName}-${project.version}" + ".jar") {
                        //release jar - file location not provided anywhere in loom
                        classifier null
                        builtBy remapJar
                    },
                    artifact("${project.buildDir.absolutePath}/libs/${archivesBaseName}-${project.version}-dev" + ".jar") {
                        //release jar - file location not provided anywhere in loom
                        classifier "dev"
                        builtBy remapJar
                    },
                    artifact(tasks.sourcesJar)
            ]
        }
    }
    /* Supply an ext block in private.gradle like so:
       ext { mavenSnapshotDir="file:///some_local_directory_path" }
     * and then just run "./gradlew publish" to save the artifacts to the specified directory, in a way that they can be
     * served by apache or your favorite httpd and behave like a maven repo. Complete with verification hashes.
     */
    repositories {
        if (rootProject.ext.has("localMavenUrl")) {
            maven {
                url = rootProject.ext.localMavenUrl
            }
        }
    }
}

artifactory {
    if (project.hasProperty("artifactoryUsername")) {
        contextUrl = 'http://server.bbkr.space:8081/artifactory/'
        publish {
            repository {
                if (version.contains("SNAPSHOT")) {
                    repoKey = "libs-snapshot"
                } else {
                    repoKey = "libs-release"
                }
                username = artifactoryUsername
                password = artifactoryPassword
            }
            defaults {
                publications('maven')

                publishArtifacts = true
                publishPom = true
            }
        }
    } else {
        println "Cannot configure artifactory; please define ext.artifactoryUsername and ext.artifactoryPassword before running artifactoryPublish"
    }
}

//Producing the entity event files.

def entityNames = [
        "item",
        "experience_orb",
        "area_effect_cloud",
        "egg",
        "leash_knot",
        "painting",
        "arrow",
        "snowball",
        "fireball",
        "small_fireball",
        "ender_pearl",
        "eye_of_ender",
        "potion",
        "experience_bottle",
        "item_frame",
        "wither_skull",
        "tnt",
        "falling_block",
        "firework_rocket",
        "spectral_arrow",
        "shulker_bullet",
        "dragon_fireball",
        "command_block_minecart",
        "boat",
        "minecart",
        "chest_minecart",
        "furnace_minecart",
        "tnt_minecart",
        "hopper_minecart",
        "spawner_minecart",
        "llama_spit",
        "end_crystal",
]
def livingEntity = [
        "elder_guardian",
        "wither_skeleton",
        "stray",
        "husk",
        "zombie_villager",
        "skeleton_horse",
        "zombie_horse",
        "armor_stand",
        "donkey",
        "mule",
        "evoker",
        "vex",
        "vindicator",
        "illusioner",
        "creeper",
        "skeleton",
        "spider",
        "giant",
        "zombie",
        "slime",
        "ghast",
        "zombie_pigman",
        "enderman",
        "cave_spider",
        "silverfish",
        "blaze",
        "magma_cube",
        "ender_dragon",
        "wither",
        "bat",
        "witch",
        "endermite",
        "guardian",
        "shulker",
        "pig",
        "sheep",
        "cow",
        "chicken",
        "squid",
        "wolf",
        "mooshroom",
        "snow_golem",
        "ocelot",
        "iron_golem",
        "horse",
        "rabbit",
        "polar_bear",
        "llama",
        "parrot",
        "villager",
        "player",
        "pillager",
        "drowned",
        "phantom",
        "ravager"
]


def entityEvents = [
        "tick", "swim_start", "damage", "killed_other", "struck_by_lightning"
]

def livingEntityEvents = [
        "attacking", "death"
]

task removeGeneratedData(type: Delete) {
    delete project.ext.generatedResources
}

task generateEntityEventFunctions {
    //we remove the generated folder, otherwise the check events become too long from constant appending.
    dependsOn removeGeneratedData
    doFirst {
        def generatedResources = project.ext.generatedResources + "/data/functionapi/functions/api/entity"
        def generatedMinecraftResources = project.ext.generatedResources + "/data/minecraft/functions/function_api/entity"

        entityEvents.each { eventName ->
            (entityNames + livingEntity).each { entityName ->

                file(generatedMinecraftResources + "/$entityName/run_${entityName}_${eventName}.mcfunction").with {
                    parentFile.mkdirs()
                    it.write("event create minecraft:$entityName $eventName entity\n" +
                            "event run minecraft:entity/$entityName/$eventName")
                }

                file(generatedResources + "/check_${eventName}.mcfunction").with {
                    parentFile.mkdirs()
                    it.append("execute if entity @s[type=minecraft:$entityName] run function minecraft:function_api/entity/$entityName/run_${entityName}_${eventName}\n")
                }
            }
            def tagFolder = project.ext.generatedResources + "/data/functionapi/tags/functions/function_api/entity/entity/"

            file(tagFolder + "/${eventName}.json").with {
                it.parentFile.mkdirs()
                it.write(
                        """
{
  "replace": false,
  "values": [
     "functionapi:api/entity/check_${eventName}"
  ]
}
""")
            }

        }

        livingEntityEvents.each { eventName ->
            (livingEntity).each { entityName ->

                file(generatedMinecraftResources + "/$entityName/run_${entityName}_${eventName}.mcfunction").with {
                    parentFile.mkdirs()
                    it.write("event create minecraft:$entityName $eventName entity\n" +
                            "event run minecraft:entity/$entityName/$eventName")
                }

                file(generatedResources + "/check_${eventName}.mcfunction").with {
                    parentFile.mkdirs()
                    it.append("execute if entity @s[type=minecraft:$entityName] run function minecraft:function_api/entity/$entityName/run_${entityName}_${eventName}\n")
                }
            }
            def tagFolder = project.ext.generatedResources + "/data/functionapi/tags/functions/function_api/entity/entity/"

            file(tagFolder + "/${eventName}.json").with {
                it.parentFile.mkdirs()
                it.write(
                        """
{
  "replace": false,
  "values": [
     "functionapi:api/entity/check_${eventName}"
  ]
}
""")
            }

        }
    }
}


classes.dependsOn generateEntityEventFunctions


task generateEventReference() {
    doLast {
        FileTree tree = fileTree('src')
        def doc = new File("docs/eventReference.md")

        doc.write("""
Function API Event reference. This document has been generated from the source code of the mod!

The event names are normal identifiers. To get the tag that you can use to bind a function file is as follows:

event name: `minecraft:block/dirt/broken`

tag name: `minecraft:function_api/block/dirt/broken`


If an event is blocking, then it will pause the game until the execution is done, so it CAN cause lagspikes! (non blocking events will run when the server has time for it)

| name  | includes | blocking |
|---|---|---|
""")
        
        tree.each { file ->
            Pattern pattern = Pattern.compile("GlobalEventContainer\\.getInstance\\(\\)\\.execute(Event|EventBlocking)\\((.*?), \"(.*?)\",([^;\n]+|[^{])")
            def found = file.readLines().join("\n").findAll(pattern)
            if (!found.isEmpty()) {
                println(file.name)
                found.each {

                    def params = it.replaceAll("^GlobalEventContainer\\.getInstance\\(\\)\\.executeEvent(|Blocking)\\(", "")
                    params = params.split(",", 3)
                    switch (params[0]) {
                        case "(ScriptedObject) blockState.getBlock()":
                        case "(ScriptedObject) this.getBlock()":
                        case "(ScriptedObject) block":
                            params[0] = "block"
                            break;
                        case "Target.ENTITY_TARGET":
                            params[0] = "entity"
                            break;
                        default:
                            if (file.name == "BlockMixin.java")
                                params[0] = "block"
                            break;
                    }
                    params[1] = params[1].replaceAll("\"","").trim()

                    def components = params[2]
                            .replaceAll("ServerCommandSourceFactory.INSTANCE.create\\(", "")
                            .replaceAll("\\)\\)\\) \\{", "")
                            .replaceAll("\\)\\)", "")
                            .split(",")
                            //.reverse()
                            .toList()
                    
                    components.removeAt(0)
                    components.removeAt(0)

                    if(components.size() ==1){
                        components ="The source entity, running it it's position"
                    }
                    if(components.size() ==2){
                        components ="The source block, running it it's position"
                    }
                    if(components.size() ==3){
                        components ="The source block, running it it's position, also the entity that is the source of this interaction"
                    }

                    def isBlocking = "No"
                    
                    if(params[1].contains("before/")){
                        isBlocking = "Yes, can be cancelled!"
                    }
                    if(params[1].contains("after/") ){
                        isBlocking = "Yes"
                    }
                    
                    println(components)
                    doc.append("| \\<namespace\\>:${params[0]}/\\<name\\>/${params[1]}|${components}|$isBlocking|\n")

                    println(params)

                }
            }
        }
    }
}